# 넷플릭스 테크 스택 (CI/CD)
![image](https://github.com/user-attachments/assets/d5414bc3-8835-4c8c-a350-664cf3badad2)
![image](https://github.com/user-attachments/assets/b80d6015-8028-439e-a6c1-6d43a7453ac7)

## **1. 계획(Planning)**

- JIRA를 사용해 계획을 세우고, Confluence를 사용해 문서를 작성
- **JIRA**:
    - 소프트웨어 개발을 위한 애자일 프로젝트 관리 도구
    - 기능: 작업 추적, 스프린트 계획, 이슈 관리
- **Confluence**:
    - 팀의 협업과 문서화를 위한 도구
    - 기능: 팀 간 지식 공유, 프로젝트 문서 관리, 기술 문서 작성
    

## **2. 코딩(Coding)**

- 백엔드 서비스 주요 언어로 Java를 사용하며, 용도에 따라 Python, Node.js, Scala 등 다양한 언어를 추가로 사용

## **3. 빌드(Build)**

- Gradle을 주로 빌드 도구로 사용하며, 다양한 사용 사례를 지원하기 위해 Gradle 플러그인을 개발함
- **Gradle**:
    - 고성능과 유연성을 가진 오픈 소스 빌드 도구로, 빌드 속도와 확장성을 제공

## **4. 패키징(Packaging)**

- 패키지와 종속성은 아마존 머신 이미지(AMI)에 포함되어 릴리스됨
- **Amazon Machine Image (AMI):**
    - AWS에서 제공하는 가상 머신 이미지로, 애플리케이션과 종속성을 포함하여 일관된 환경을 제공
    

## **5. 테스트(Testing)**

- 넷플릭스의 프로덕션 중심 문화에 맞게 Chaos 도구를 강조한 테스트가 진행됨
- **Chaos Engineering**:
    - 의도적으로 **혼란(Chaos)**를 주입해 시스템의 **복원력**과 **안정성**을 검증하고 향상시키는 접근 방식
    - Netflix가 설계한 Chaos Monkey, Chaos Kong 등 혼란 주입 도구를 통해 시스템 복원력 검증
    - 목적: 장애 발생 시 시스템의 신뢰성을 테스트하고, 프로덕션 환경에서의 문제를 사전에 발견

## **6. 배포(Deployment)**

- 넷플릭스는 자체적으로 구축한 Spinnaker를 사용해 카나리 롤아웃 방식으로 배포를 진행
- **카나리 롤아웃 배포**: 카나리 배포와 롤아웃 배포를 결합한 방식으로, 새로운 버전을 점진적으로 배포하며 동시에 각 단계에서 안정성을 평가
    - 새 버전을 일부 서버에 배포하고 안정성을 평가한 후 안정적이면 배포를 확장
- **Spinnaker**:
    - 넷플릭스와 구글이 공동 개발
    - 멀티 클라우드 환경을 지원하는 오픈 소스 지속적 배포 도구
    - 카나리 배포 및 단계적 배포를 통해 서비스 중단 최소화

## **7. 모니터링(Monitoring)**

- 모니터링 지표는 Atlas에 중앙 집중화 되며,  케이엔타(Kayenta)를 사용하여 이상(anomaly)을 감지
- **Atlas**:
    - Netflix가 개발한 내부 모니터링 도구로 실시간 메트릭 수집 및 시각화 지원
- **Kayenta**:
    - Netflix의 카나리 분석 도구로, 새로운 버전이 기존 버전보다 안정적인지 판단

## **8. 사건 보고(Incident report)**

- 사건은 우선순위에 따라 처리되며, PagerDuty를 통해 사건을 처리
- **PagerDuty**:
    - 사건 발생 시 알림을 전송하고 우선순위에 따라 적절한 대응 팀 호출
 
## 참고
https://github.com/ByteByteGoHq/system-design-101/?tab=readme-ov-file#cicd



# 리버스 프록시

서버의 앞단에 위치. 사용자 요청을 대신 처리하고 서버를 보호하는 역할을 함

### 리버스 프록시 역할

- 서버 보호
- 로드 밸런싱
- 캐힝
- SSL

### 리버스 프록시 작동 과정

1. 사용자가 웹사이트에 요청 보냄
2. 리버스 프록시 서버가 요청을 대신 받아 내부 서버로 전달
3. 내부 서버에서 응답을 받고, 리버스 프록시 서버가 사용자에게 다시 전달

### 리버스 프록시와 포워드 프록시 차이

**포워드 프록시**

- 사용자 앞단에 위치
- 사용자를 보호하고 익명성 제공
- 주로 사용자나 기업이 사용
- 예시) 지역 제한 우회, 접근 제어, 익명 브라우징

**리버스 프록시**

- 서버 앞단에 위치
- 서버를 보호하고 부하를 분산
- 주로 서버 운영자가 사용
- 예시) 로드 밸런싱, 캐싱, 디도스 방어

## 왜 nginx가 리버스 프록시로 사용될까?

nginx가 로드 밸런싱, 보안 강화, 캐싱, SSL 암호화를 해줌

# URL, URN, URI
## URL

- 자원의 위치를 나타냄 (locator)
- 자원의 접근방식(프로토콜)과 위치를 보함
- http:// 이런거 써줘야함

## URN

- n : name
- 리소스에 이름을 부여
- 리소스의 접근 방법과 웹 상의 위치가 표기되지 않음
- 실제 자원을 찾기 위해선 URN을 URL로 변환해 사용

## URI

- Identifier
- 통합 자원 식별자
- 인터넷에 있는 자원을 어디에 있는지 자원 자체를 식별하는 방법
- 프로토콜 필수
- URI의 하위 개념으로 URL과 URN이 있음

# 디자인패턴
## 1. 생성 패턴

객체 생성의 유연성과 재사용성을 높이기 위한 디자인 패턴

### 추상 팩토리

개념

- 추상화와 구현을 분리해 두 부분이 독립적으로 변화할 수 있게 하는 패턴

장점

- 저장소 구현 변경이 쉬움
- 코드 재사용성 향상

단점

- 계층 구조가 복잡해질 수 있음
- 클래스 수 증가

### 빌더

개념

- 복잡한 객체의 생성 과정과 표현 방법을 분리해 단계적으로 객체 생성
- 게시글처럼 여러 필수/선택 필드를 가진 객체 생성에 적합

장점

- 게시글 생성 과정의 세밀한 제어 가능
- 유효성 검사를 빌더 내에서 처리
- 가독성 향상

단점

- 별도의 빌더 클래스 필요
- 간단한 객체 생성에는 과도한 패턴일 수 있음

### 프로토타입

개념

- 기존 객체를 복제하여 새로운 객체를 생성하는 패턴
- 자주 사용되는 게시글 형식을 템플릿으로 만들어 재사용

장점

- 자주 사용되는 형식의 게시글을 쉽게 생성
- 템플릿 수정이 용이
- 객체 생성 비용 절감

단점

- 순환 참조가 있는 복잡한 객체의 복제가 어려움
- 깊은 복사 구현의 복잡성

<aside>
💡

**프로토타입 vs 추상화**

프로토타입 : 기존 객체를 복제하여 새로운 객체를 생성하는 것이 목적

추상화 : 복잡한 시스템을 단순화하고 핵심 개념만 남기는게 목적

</aside>

### 싱글톤

개념

- 클래스의 인스턴스가 오직 하나만 생성되도록 보장하고 전역적인 접근점 제공
- 사용자 세션, 설정 관리 등 공유 리소스 관리에 적함

장점

- 인스턴스의 유일성 보장
- 전역적 접근점 제공
- 공유 리소스에 대한 동시성 제어 용이

단점

## 구조 패턴

클래스와 객체를 더 큰 구조로 조합하는 방법을 다루는 디자인 패턴

### 어댑터

- 외부 인증 시스템 통함

개념

- 호환되지 않는 인터페이스들을 함께 동작하도록 만드는 패턴
- 서로 다른 인증 시스탬(구글, 카카오, 네이버 등) 을 통합할 때 유용

장점

- 코드 수정 없이 새로운 인증 시스템 축 가능
- 재사용성 증가

단점

- 어댑터 클래스 추가로 인한 복잡도 증가
- 새로운 인증 시스템마다 어댑터 구현 필요

### 브리지

개념

- 추상화와 구현을 분리해 둘을 독립적으로 변형할 수 있게 하는 패턴

장점

- 저장소 구현 변경 용이
- 새로운 저장소 추가 쉬움
- 결합도 감소

단점

### 컴포지트

개념

- 객체들을 트리 구조로 구성해 부분-전체 계층 구조를 구현하는 패턴

장점

- 복잡한 트리 구조 쉽게 구현
- 새로운 종류의 구성요소 추가 용이
- 클라이언트 코드 단순화

단점

- 제약 조건 설계 어려움
- 트리 구조 변경의 복잡성

### 데코레이터

개념

- 객체에 동적으로 새로운 책임을 추가하는 패턴

장점

- 기존 코드 수정 없이 기능 추가 가능
- 단일 책임 원칙 준수
- 실행 중에 기능 추가/제거 가능

단점

- 데코레이터 순서에 따라 결과가 달라질 수 있음
- 작은 객체가 많이 생성될 수 있음

### 퍼사드

개념

- 복잡한 서브시스템에 대한 단순화된 인터페이스 제공

장점

- 서브시스템 사용 편의성 증가
- 서브시스템 간 결합도 감소
- 클라이언트 코드 단순화

단점

- 퍼사드가 모든 서브시스템 알아야함

## 3. 행위 패턴

객체들이 서로 상호작용하고 책임을 분배하는 방식을 다루는 디자인 패턴

### 플라이웨이트

개념

- 많은 수의 유사한 객체를 효율적으로 공유해 메모리 사용을 최적화하는 패턴

장점

- 메모리 사용량 감소
- 객체 생성 비용 절감
- 성능 향상

단점

- 코드 복잡도 증가
- 공유 상태 관리 어려움

### 프록시

개념

- 객체에 대한 접근을 제어하는 대리자 제공

장점

- 보안성 향상

단점

### 책임 연쇄

개념

- 요청을 처리할 수 있는 기회를 여러 객체에게 부여

장점

- 처리 순서 동적 변경 가능
- 단일 책임 원칙 준수
- 새로운 처리 단계 추가 용이

단점

- 처리 단계가 많으면 성능 저하
- 처리 보장 안될 수 있음

### 커맨드

개념

- 요청을 객체로 캡슐화하여 매개변수화

장점

- 작업의 큐잉과 로깅 가능
- 실행 취소/재실행 구현 용이
- 작업 상태 추적 가능

단점

- 클래스 수 증가
- 시스템 복잡도 증가

### 반복자

개념

- 컬렉션의 내부 구조를 노출하지 않고 순차적으로 요소에 접근하는 방법 제공

### 중재자

개념

- 객체 간의 복잡한 통신을 중앙화하여 처리
- 실시간 채팅, 알림 시스템 구현에 활용

장점

- 객체 간 결합도 감소

단점

- 중앙화로 인한 병목 가능성

### 메멘토

개념

- 객체의 상태를 저장하고 복원하는 기능 제공

장점

- 상태 저장와 복원 캡술화
- 실행취소 기능 구현 용이
- 객체 상태 이력 관리 가능

단점

- 메모리 사용량 증가
- 저장할 상태가 클 경우 비용 증가

### 옵저버

개념

- 객체의 상태 변화를 다른 객체에 자동으로 알리는 패턴
- 게시글 구독, 알림 설정 기능에 유용

장점

- 느슨한 결합도 유지
- 상태 변경 자동 전파
- 런타임에 구독 관계 변경 가능

단점

- 순서 의존적인 갱신 처리 어려움
- 메모리 누수 가능

### 방문자

개념

- 객체 구조를 변경하지 않고 새로운 동작을 추가
- 게시글 통계, 분석 기능 구현에 활용

장점

- 기존 코드 수정 없이 새로운 동작 추가
- 관련 동작을 한 클래스에 모음
- 데이터와 알고리즘 분리

단점

- 데이터 구조 변경 시 모든 방문자 수정 필요
