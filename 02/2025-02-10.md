![image](https://github.com/user-attachments/assets/47d37f5e-cc8c-49b4-8edb-f57dad1d91db)

## 투포인터 (Two Pointers)

- 배열 등의 선형 자료구조에서, 두 개의 포인터(인덱스)를 이용해 문제를 해결하는 알고리즘 기법
- 포인터를 동시에 움직이면서 특정 조건(합, 차이, 구간 길이 등)을 만족하는 구간을 효율적으로 찾아내는데 사용됨

## 활용

- 정렬된 배열에서 특정 값의 합을 찾는 문제
- 구간(슬라이딩 윈도우, 연속 부분수열 등) 내에서 조건(합, 길이, 최대/최솟값 등)을 만족하는 문제
- 문자열에서 투 포인터를 이용한 서브스트링 탐색 문제

## 동작 방식

1. **포인터 초기화**
    - 문제 유형에 따라 두 포인터의 시작 위치를 정함
        - 예) `left = 0`, `right = n-1` (정렬된 배열에서 합 찾기)
        - 예) `start = 0`, `end = 0` (슬라이딩 윈도우)
2. **구간(또는 값) 확인**
    - 현재 두 포인터가 나타내는 구간(또는 값)의 합, 길이, 조건 등을 검사
3. **조건 만족 시 처리**
    - 조건을 충족한다면 원하는 결과를 얻거나, 결과를 기록
    - 조건을 만족해도 추가 탐색이 필요한 경우(최댓값·최솟값, 모든 경우 찾기 등)는 계속 진행
4. **포인터 이동**
    - 조건을 만족했는지 여부에 따라 한쪽(또는 양쪽) 포인터를 적절히 이동
    - 예) 구간 합 < 목표 → 오른쪽 포인터 증가, 구간 합 > 목표 → 왼쪽 포인터 감소 등
5. **종료**
    - 두 포인터가 교차하거나, 배열 범위를 벗어나는 등 탐색 불가능 상태가 되면 반복을 종료
    - 기록해둔 결과(합, 길이, 인덱스 등)를 반환

## 투 포인터 알고리즘 예시

### 정렬된 배열에서 두 수의 합 찾기

문제 : 정렬된 배열 `arr`와 정수 `K`가 주어질 때, `arr`의 서로 다른 두 원소를 더해 `K`가 되는 쌍을 모두 찾아라.

```python
def two_sum(arr, K):
    arr.sort()  # 만약 미정렬 상태라면 정렬, [1, 2, 2, 3, 5, 7, 9]
    i, j = 0, len(arr) - 1
    results = []
    
    while i < j:
        current_sum = arr[i] + arr[j]
        
        if current_sum == K:
            results.append((arr[i], arr[j]))
            i += 1
            j -= 1
            
            # 같은 값이 연속해서 나오는 경우 중복 방지
            while i < j and arr[i] == arr[i - 1]:
                i += 1
            while i < j and arr[j] == arr[j + 1]:
                j -= 1
                
        elif current_sum < K:
            i += 1
        else:
            j -= 1
    
    return results

# 사용 예시
arr = [1, 3, 2, 5, 7, 9, 2]
K = 10
print(two_sum(arr, K))  # [(1, 9), (3, 7)]
```

## 장점

- **선형 시간 `O(n)`** 으로 문제 해결 가능
    - 일반적으로 이중 반복문을 사용하면 `O(N^2)`이 소요되지만, 투 포인터는 한 번의 스캔으로 가능한 경우가 많음.
- 메모리 절약
    - 추가적인 자료구조를 필요로 하지 않는 경우가 대부분.
- 구현 간단
    - 알고리즘 로직은 단순한 편이지만, 인덱스 범위 관리와 조건 처리가 중요

## 시간복잡도

투 포인터 알고리즘은 대부분 **`O(N)`** 혹은 **`O(N log N)`**(초기에 정렬이 필요한 경우) 내에 해결 가능!

## 슬라이딩 윈도우와 차이점

![image](https://github.com/user-attachments/assets/dfacf043-549a-4e2e-8c61-a09d20408fa3)
[사진 출처](https://velog.io/@zwon/%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%9C%88%EB%8F%84%EC%9A%B0Sliding-Window)

슬라이딩 윈도우는 투포인터처럼 구간을 훑으면서 지나간다는 공통점이 있으나, **슬라이딩 윈도우는 어느 순간에도 구간의 넓이가 동일하다**는 차이점이 있다.

## 참고

https://butter-shower.tistory.com/226

https://adjh54.tistory.com/384

[https://velog.io/@zwon/슬라이딩-윈도우Sliding-Window](https://velog.io/@zwon/%EC%8A%AC%EB%9D%BC%EC%9D%B4%EB%94%A9-%EC%9C%88%EB%8F%84%EC%9A%B0Sliding-Window)
