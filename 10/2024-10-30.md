## 🗓️ 2024-10-30
### 🗯️ 스크럼
- 학습 목표 1 : 커뮤니티 레이아웃 완성
- 학습 목표 2 : 리틀리 과제 끝내기

### ✏️ 새로 배운 내용
#### Stateful (상태 유지)

> **Stateful** : 클라이언트-서버 관계에서, 서버가 클라이언트의 상태를 보존함


- 클라이언트와 서버가 데이터 송수신을 통해 단계별 작업을 진행할 때, 서버는 **이전 단계에서 클라이언트가 제공한 정보를 저장**한다. 이후 단계에서도 이 데이터를 사용해 상태를 유지한다.
- **예시** :  웹사이트에 로그인한 후 페이지를 이동해도 서버가 클라이언트의 로그인 상태를 유지(기억)하고 있기 때문에 로그인이 풀리지 않고 계속 유지되는 것.
- **상태 저장 위치** : 클라이언트의 상태를 기억하기 위해서는 특정 저장소에 정보가 보존된다. 이는 보통 브라우저의 `쿠키(Cookie)`에 저장되거나 서버의 `세션(Session)` 메모리에 저장되어 상태가 유지된다.


##### Stateful 한 프로토콜 : TCP 3-way handshaking

![image](https://github.com/user-attachments/assets/068858d8-2a6a-4032-8158-094c693dc7ab)


1. **SYN 패킷 전송 (클라이언트 → 서버)**
    - 클라이언트가 서버에 연결 요청하며 `SYN 패킷`을 전송
    - 이때 클라이언트는 `SYN_SENT` 상태로 들어가며, 서버로부터 응답을 기다림
2. **SYN-ACK 패킷 전송 (서버 → 클라이언트)**
    - 서버는 클라이언트의 `SYN 패킷`을 수신하고 연결 요청을 승인
    - 서버는 클라이언트에게 자신의 `SYN`과 응답 `ACK`를 포함한 `SYN-ACK 패킷`을 전송
    - 이 과정에서 서버는 `SYN_RECEIVED` 상태가 됨
3. **ACK 패킷 전송 (클라이언트 → 서버)**
    - 클라이언트는 서버의 `SYN_ACK 패킷`을 수신하고, 서버에 `ACK 패킷`을 보내 연결을 최종 확립
    - 이 패킷이 서버에 도달하면, 서버와 클라이언트 모두 `ESTABLISHED` 상태가 되어 데이터 전송이 가능한 연결 상태로 들어감

##### Stateful의 단점

- **서버 장애 시 문제** : 특정 서버에 클라이언트 상태가 저장되기 때문에, 해당 서버가 중단되거나 사용할 수 없게 되면 문제가 생긴다. 다른 서버로 전환되더라도 새로운 서버에는 **이전 상태값이 없기 때문**이다.
- **서버 부담**  ⬆️ : 서버가 클라이언트 상태를 보존하기 위해 메모리를 사용하므로, 많은 사용자를 동시에 처리할 경우 서버의 부담이 커진다.


#### Stateless (무상태)


>**Stateless** : 클라이언트-서버 관계에서, 서버가 클라이언트의 상태를 보존하지 않음


- 서버의 역할 : 단순히 클라이언트 요청에 대한 응답만을 수행하며, 이전 요청의 상태를 저장하지 않는다. 상태 정보는 전적으로 클라이언트가 관리한다.
- 즉, 클라이언트와 서버 간의 통신에 필요한 **모든 상태 정보들은 클라이언트가 가지고 있다가** 서버에 요청할 때 함께 전송
- **서버 부담 ⬇️** : 서버는 상태를 저장할 필요가 없어 상태 관리에 따른 부담이 줄어들고, 더 많은 요청을 효율적으로 처리할 수 있음
- **안정성** ⬆️ : 서버가 상태를 유지하지 않기 때문에, 특정 서버가 중단되더라도 다른 서버가 이어서 응답을 처리할 수 있어 안정성이 높다.

##### Stateless한 프로토콜 : UDP, HTTP

대표적인 Stateless 프로토콜로 `UDP`와 `HTTP`가 있다.

- **UDP**
    - **TCP와의 차이점** : UDP는 TCP와 달리 3-way 핸드셰이크 같은 연결 확인 절차 없이 데이터가 곧바로 전송됨
    - 서버는 클라이언트와의 **연결 상태를 관리하지 않고**, 클라이언트가 보낸 데이터의 **수신 여부도 확인하지 않는다**. 따라서 서버는 클라이언트의 **세션 정보 없이 데이터를 받는 즉시 응답**한다.
    - 위와 같은 이유로 빠른 전송이 가능하여 실시간 통신이 중요한 애플리케이션 (스트리밍 등)에 자주 사용된다.
- **HTTP**
    - 기본적으로 무상태로 작동하여 각 요청이 독립적으로 처리됨
    - 브라우저가 서버에 요청을 보낼 때마다 새로 연결을 하고, 데이터를 전송한 뒤 연결을 끊음
    - `쿠키`와 `세션` 같은 추가 기술을 통해 **Stateful한 방식도 가능**

##### Stateless 단점

- **많은 데이터 소모** : 클라이언트가 요청할 때마다 필요한 모든 상태 정보를 포함해야 하므로 Stateful 방식보다 더 많은 데이터가 전송됨

##### Stateless와 토큰

Stateless 방식에선 서버가 클라이언트의 상태를 저장하지 않고 요청에 대한 응답만을 수행하기 때문에 서버 부하가 줄어드는 장점이 있다.

하지만 **로그인 유지**와 같은 기능을 위해 상태 저장이 필요한 경우가 생기기도 한다.

이때 Stateless 특징을 유지하면서도 로그인 상태를 유지할 수 있게 하는 기술이 바로 `JWT 토큰`이다.

주로 HTTP 요청의 헤더에 JWT를 포함하여 클라이언트가 서버에 보낸다. 서버는 매 요청에서 JWT를 확인해 사용자를 인증한다.

### 🤔 오늘의 회고
- 딥다이브를 위해 남들이 쉽게 이해할 수 있도록 설명을 준비하면서, 나 역시 개념을 더 체계적으로 정리하고 깊이 이해할 수 있었다. 

### 🔗 참고 자료 및 링크
- [https://inpa.tistory.com/entry/WEB-📚-Stateful-Stateless-정리#Stateless_와_http_/_rest](https://inpa.tistory.com/entry/WEB-%F0%9F%93%9A-Stateful-Stateless-%EC%A0%95%EB%A6%AC#stateless_%EC%99%80_http_/_rest)
- https://www.techopedia.com/definition/10339/three-way-handshake (이미지)
- https://wooono.tistory.com/366
