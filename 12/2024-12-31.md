## DP란?

> 복잡한 문제를 **더 작은 하위 문제로 나누어** 해결하는 알고리즘 설계 기법
> 
- 계산한 건 다시 계산하지 않는 것이 중요
- 메모리 공간을 약간 더 사용해 연산 속도를 비약적으로 증가시킴

## DP 사용 조건

1. **최적 부분 구조**
    - 큰 문제를 작은 문제로 나눌 수 있다.
2. **겹치는 부분 문제**
    - 동일한 작은 문제들이 중복되어 사용되는 경우에 사용 가능

## DP의 두 가지 방식

### 1. Tabluation(도표 작성) , Bottom-Up

- 더 작은 하위 문제부터 살펴본 다음 **작은 문제의 정답을 이용해 큰 문제의 정답을 풀어나가는 방법**
- 불필요한 계산까지도 포함할 가능성이 있음

```python
# DP
# 타뷸레이션 (상향식)

def fib(n):

    dp = [0]*(n+1)
    dp[0] = 1
    dp[1] = 1
    
    # 작은 값(소문제)부터 직접 계산하며 진행 
    for i in range(2,n+1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]

fib(10)
```

### 2. Memoization(기억), Top-Down

- **메모이제이션** : 한 번 구한 계산 결과를 메모리 공간에 메모해두고, 같은 식을 다시 호출하면 **메모한 결과를 그대로 가져오는** 기법
- **재귀함수**로 구현

```python
# DP 
# memoization (하향식)

dp = [0]*100 # 소문제 결과를 저장할 리스트
dp[0] = 1 
dp[1] = 1

def fib(n):
    
    # 만약 계산한 적이 없다면 재귀로 계산 
    if dp[n] == 0:
        dp[n] = fib(n-1) + fib(n-2)
    
    # 있다면 그대로 반환 
    return dp[n]

fib(10)
```

## DP 문제인지 알아보는 법

1. DFS/BFS로 풀 수 있지만 경우의 수가 너무 많은 문제
    - 주로 **DFS/BFS는 경로 탐색**, **DP는 최적값 계산**에 적합
2. 중복된 연산이 많은 경우
    - 각 위치까지 올 수 있는 최적의 조합만 남겨두고 나머지는 버림
