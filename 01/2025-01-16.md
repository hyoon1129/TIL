# Git 작동 원리
![image](https://github.com/user-attachments/assets/fc142c2e-7bd3-4751-b455-0fbb2eb13e56)


> **Git :** 분산형 버전 관리 시스템


## 버전 관리란?

- 파일 변화를 시간에 따라 기록했다가 특정 시점의 버전을 다시 꺼내올 수 있는 시스템

- 각 파일을 이전 상태로 되돌릴 수 있음
- 프로젝트 전체를 특정 시점으로 복원 가능
- 시간에 따른 수정 내역 비교 가능
- 누가 어떤 문제를 일으켰는지 추적 가능
- 누가 언제 만든 이슈인지 확인 가능
- 파일을 잃어버리거나 잘못 수정했을 때 쉽게 복구 가능

## Git 작동 구조

Git은 분산형 버전 관리 시스템으로, 로컬 저장소와 원격 저장소를 기반으로 작업한다.

![image](https://github.com/user-attachments/assets/e2c96064-bcc9-44a9-8749-fb3136061297)

- 내 로컬 저장소에서 작업한 것을 원격 저장소로 밀어내거나 (push), 원격 저장소에서 최신 형상을 내 작업 공간(로컬 저장소)로 당겨온다 (pull)

### **1. 작업 디렉토리 (Working Directory)**

- 사용자가 현재 작업 중인 실제 파일들이 위치한 디렉토리
- 컴퓨터의 파일 시스템에서 볼 수 있는 실제 파일과 폴더
- 아직 Git의 추적을 받지 않거나 스테이징 되지 않은 파일들이 위치
- Git이 변경 사항을 추적하기 전의 상태를 보여줌
- Git 명령어를 실행하지 않아도 사용자는 자유롭게 작업 가능
- 예) 파일을 새로 생성하거나, 코드를 수정해도 Git은 아직 해당 변경 사항을 인지하지 못한다

### **2. 스테이징 영역 (Staging Area)**

- 커밋될 변경 사항을 임시로 저장하는 공간
- `git add` 명령으로 파일을 이 영역에 추가

### **3. 로컬 저장소 (Local Repository)**

- Git이 관리하는 버전 기록이 저장된 데이터베이스
- 커밋된 변경 사항들이 저장되는 공간
- 사용자의 컴퓨터 내부에 존재하며, `.git` 폴더 안에 저장됨
- 인터넷 연결 없이도 변경 사항을 추적 가능
- 로컬 레포지토리는 Git 명령어를 통해서만 변경이 이루어진다

### **4. 원격 저장소 (Remote Repository)**

- 로컬 저장소의 데이터를 공유하고 협업을 위해 사용하는 중앙 서버
- `git push` 명령으로 로컬 변경 사항을 원격 저장소에 반영
- `git pull` 명령으로 원격 저장소의 최신 변경 사항을 로컬로 가져옴

## 기본 용어

### **1. 커밋 (Commit)**

- 스테이징 영역의 파일들을 로컬 저장소에 저장하는 작업
- 커밋은 Git에서 프로젝트의 상태를 저장하는 스냅샷을 생성
- 커밋에는 파일의 변경 사항과 함께 커밋 메시지가 포함되어 있어 변경 사항의 의미를 기록할 수 있음
- 각 커밋은 고유한 ID(해시 값)을 가지며, 이를 통해 특정 커밋으로 쉽게 돌아갈 수 있음
- 예시

```bash
git commit -m "feat: 로그인 기능 추가"
```

### **2. 스냅샷 (Snapshot)**

- 특정 시점에서 파일, 폴더 또는 워크스페이스의 상태를 기록한 것
- 특정 시점의 모든 파일과 폴더 구조를 저장소에 저장하며, 파일의 내용뿐만 아니라 파일의 메타데이터도 포함됨
- 이를 통해 사용자는 저장소의 이전 상태를 정확히 복원하거나 비교할 수 있음
- Git의 핵심 개념으로 변경된 부분만 저장해 효율성을 극대화한다.

### **3. 체크아웃 (Checkout)**

- 이전 버전 작업 불러오는 것
- 브랜치나 특정 커밋으로 작업 디렉토리를 변경하는 데 사용됨
- 체크아웃 시, 작업 디렉토리와 스테이징 영역이 해당 커밋의 상태로 변경됨
- 작업 중인 파일이 커밋되지 않았다면 데이터가 손실될 수 있으니, 반드시 저장 후 진행해야 한다!
- 예시

```bash
git checkout <브랜치명>
git checkout <커밋 ID>
```

### **4. 헤드 (Head)**

- 현재 작업 중인 브랜치를 가리키는 포인터
- 현재 체크아웃된 브랜치 또는 커밋을 나타냄
- Git은 HEAD를 기준으로 커밋을 추가하거나, 이전 상태로 이동

### **5. 브랜치 (Branch)**

- 코드 변경 사항을 독립적으로 작업할 수 있는 경로
- 기본 브랜치는 `main` 또는 `master`로 생성되며, 새로운 기능 추가나 버그 수정을 위해 브랜치를 분기하여 작업
- 브랜치를 사용하면 메인 코드에 영향을 주지 않고 독립적으로 작업할 수 있음
- 예시

```bash
git branch <브랜치명>  # 브랜치 생성
git checkout <브랜치명>  # 브랜치 이동
git checkout -b <브랜치명> # 브랜치 생성과 동시에 이동
```

### **6. 머지 (Merge)**

- 한 브랜치의 변경 사항을 다른 브랜치에 병합하는 작업
- 개발 완료 후 브랜치를 `main`에 병합하여 변경 사항을 반영
- 충돌이 발생할 수 있으며, 이 경우 수동으로 해결해야 함
- 예시

```bash
git merge <브랜치명>
```

## 참고

[https://inpa.tistory.com/entry/GIT-⚡️-개념-원리-쉽게이해](https://inpa.tistory.com/entry/GIT-%E2%9A%A1%EF%B8%8F-%EA%B0%9C%EB%85%90-%EC%9B%90%EB%A6%AC-%EC%89%BD%EA%B2%8C%EC%9D%B4%ED%95%B4)

https://git-scm.com/book/ko/v2


# Git merge vs Git rebase

## Merge

![image](https://github.com/user-attachments/assets/00e756fa-3f30-4b0c-a57d-83f5cd64f070)
![image](https://github.com/user-attachments/assets/23b79710-b2d7-4da6-bc76-331eb0e6e569)

- Join two or more development histories together
- 다른 브랜치를 현재 checkout된 브랜치에 merge하는 명령
- 브랜치를 병합한 후 **새로운 병합 커밋(Merge Commit)** 을 생성하여 병합 이력을 기록
- 그림 : `feature` 브랜치에 두 브랜치의 기록을 연결하는 **새로운 “병합 커밋”이 만들어짐**

```bash
git checkout main  # main 브랜치로 이동
git merge feature  # feature 브랜치를 main 브랜치에 병합
```

### 특징

1. **병합 커밋 생성**
    - merge는 각 브랜치의 커밋 이력을 유지하면서 병합 커밋을 생성
    - 이력을 보존하며, 작업의 흐름을 명확하게 추적할 수 있음
2. **Conflict 처리**
    - 같은 파일의 같은 부분을 두 브랜치에서 수정한 경우 충돌 발생
    - 사용자가 직접 충돌을 해결한 뒤 병합 커밋을 생성해야함
3. **사용 상황**
    - 협업 시 두 브랜치의 이력을 명확히 보존하고 싶을 때 사용
    - 작업의 진행 흐름이 중요한 프로젝트에서 적합

## Rebase

![image](https://github.com/user-attachments/assets/a4a90f46-2e5d-472e-8079-cc7ae5baae27)
![image](https://github.com/user-attachments/assets/27428844-eab2-4d9b-8c6f-9d40c169ddc4)


- Reapply commits on top of another base tip
- 한 브랜치의 변경 사항을 다른 브랜치의 최상단으로 재배치하는 명령어
- merge와 같이 한 브랜치에서 다른 브랜치로 합치는 방법
- 기존 커밋 이력을 수정해 깔끔한 커밋 히스토리 유지
- 그림 : `main` 브랜치의 끝에서 시작하도록 전체 `feature` 브랜치를 이동하여 `main`에서 모든 새 커밋을 통합. 병합 커밋을 사용하는 대신 rebase는 **원본 브랜치에서 각 커밋에 대해 새로운 커밋**을 만들어 **프로젝트 기록을 다시 작성**

```bash
git checkout feature  # feature 브랜치로 이동
git rebase main       # main 브랜치의 최상단으로 feature 브랜치를 재배치
```

### 특징

1. 병합 커밋 없음
    - 커밋 히스토리를 재배치하기 때문에 merge와 달리 병합 커밋을 생성하지 않음
    - 기존 커밋 이력을 깔끔하게 유지 가능
2. 커밋 재작성
    - rebase는 기존 커밋을 새로운 부모 커밋 위에 복사하여 이력을 재작성
    - 이로 인해 커밋 해시가 변경됨
3. Conflict 처리
    - 재배치 과정에서 충돌이 발생하면 사용자가 충돌을 해결해야 함
    - 충돌 해결한 후 `git rebase --continue` 명령으로 재배치를 계속 진행
4. 사용 상황
    - 개인 작업 브랜치에서 커밋 이력을 정리하거나 깔끔한 히스토리를 유지하고 싶을 때 사용
    - rebase는 커밋 해시를 변경하므로 공유된 브랜치에는 사용하지 않는 것이 좋음. 협업 시 주의!

## **Merge vs Rebase**

| **특징** | **Merge** | **Rebase** |
| --- | --- | --- |
| **병합 커밋 생성 여부** | 병합 커밋 생성 | 병합 커밋 생성하지 않음 |
| **커밋 이력** | 각 브랜치의 이력을 보존하며 병합 | 기존 커밋 이력을 재배치하여 깔끔하게 유지 |
| **Conflict 처리** | 병합 과정에서 발생, 해결 후 병합 커밋 생성 | 재배치 중 발생, 해결 후 재배치 계속 진행 |
| **사용 목적** | 협업 시 이력 보존 및 작업 흐름을 명확히 추적 | 개인 작업 시 커밋 이력을 깔끔히 유지 |
| **장점** | 이력 보존, 작업의 흐름 명확 | 간결하고 깔끔한 커밋 히스토리 |
| **단점** | 병합 커밋이 많아지면 히스토리가 복잡해질 수 있음 | 커밋 해시 변경으로 협업 시 충돌 가능성 |

## **사용 시 주의사항**

### **Merge**

- 팀 작업에서는 이력 보존과 충돌 방지 측면에서 일반적으로 merge를 선호
- 특히 장기간 병합되지 않은 브랜치를 병합할 때 유용

### **Rebase**

- 로컬 브랜치에서만 사용하거나 **Push 전**에 커밋을 정리할 때 활용
- 이미 공유된 브랜치(예: 원격 브랜치)에서 rebase를 사용하면 협업에 문제가 발생할 수 있음

## 참고

https://git-scm.com/book/ko/v2

https://www.atlassian.com/ko/git/tutorials/merging-vs-rebasing
