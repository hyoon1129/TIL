# 비트마스킹
## 비트 연산자

- `&` : AND 연산, 두 비트가 모두 1일 때만 1을 반환함
- `|` : OR 연산, 두 비트 중 하나라도 1이면 1을 반환함
- `^` : XOR 연산, 두 비트가 다를 때만 1을 반환함
- `~` : NOT 연산, 비트를 반전시킴 (1 → 0, 0 → 1)
- `<<` : Left Shift 연산, 비트를 왼쪽으로 `n`칸 이동시킴
- `>>` : Right Shift 연산, 비트를 오른쪽으로 `n`칸 이동시킴

## 비트마스킹 기법

- **비트마스킹**은 비트를 활용해 상태를 효율적으로 저장, 관리, 조작하는 기법
- 특정 상태를 비트로 표현하고, 비트 연산을 통해 빠르고 간단하게 상태를 처리
- **사용 예시**: TSP(외판원 순회), 집합의 부분 집합 탐색, 플래그 관리 등

## 비트마스킹 활용 방법

### 1. 특정 비트 켜기

특정 상태를 활성화하는 연산

```python
visited∣=(1<<n)
```

예시

```python
visited = 0b0000
visited |= (1 << 2)  # 2번 비트 켜기
print(bin(visited))  # 출력: 0b100
```

### 2. 특정 비트 끄기

특정 상태를 비활성화하는 연산

```python
visited &= ~(1 << n)
```

```python
visited = 0b1111
visited &= ~(1 << 2)  # 2번 비트 끄기
print(bin(visited))  # 출력: 0b1011
```

### 3. 특정 비트 확인하기

```python
if visited&(1<<n):
```

예시

```python
visited = 0b1010
if visited & (1 << 3):  # 3번 비트 확인
    print("3번 비트는 켜져 있음")

```

### 4. 전체 상태 탐색하기

N개의 비트로 나타낼 수 있는 모든 상태를 탐색할 때 사용

```python
N = 3
for state in range(1 << N):
    print(f"현재 상태: {bin(state)}")
```

N = 3이므로 `1 << N` 은 2의 세제곱, 즉 8을 의미

```python
현재 상태: 0b0    # 아무 비트도 켜지지 않음
현재 상태: 0b1    # 0번 비트 켜짐
현재 상태: 0b10   # 1번 비트 켜짐
현재 상태: 0b11   # 0번, 1번 비트 켜짐
현재 상태: 0b100  # 2번 비트 켜짐
현재 상태: 0b101  # 0번, 2번 비트 켜짐
현재 상태: 0b110  # 1번, 2번 비트 켜짐
현재 상태: 0b111  # 모든 비트 켜짐
```

## 비트마스킹 장점

1. **효율적인 상태 관리**
    
    정수 하나로 여러 상태를 관리할 수 있음
    
2. **빠른 연산 속도**
    
    비트 연산은 O(1)로 매우 빠름
    
3. **메모리 절약**
    
    리스트나 튜플을 사용하는 것보다 메모리 사용량이 적음
    
4. **복잡한 상태를 간결하게 표현**
    
    여러 상태를 하나의 숫자로 표현 가능
