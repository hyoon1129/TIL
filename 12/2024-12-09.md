## 도커 사용하는 이유

- `일관성` : 개발, 테스트, 배포 환경 간의 일관된 환경 제공
- `이식성` : 운영체제와 무관하게 애플리케이션 실행 가능
- `효율성` : 리소스를 절약하고 빠르게 배포 가능
- `확장성` : **마이크로서비스 아키텍처**를 아주 잘 지원 (마이크로서비스 아키텍처 : 기능 별로 쪼갬)

## 도커 실행 기본요소

1. 컨테이너
    - 애플리케이션과 실행에 필요한 모든 것을 포함한 패키지
2. 이미지
    - 컨테이너를 실행하기 위해 필요한 모든 파일과 설정을 포함한 템플릿 파일
3. 도커파일
    - 이미지를 정의하는 스크립트
4. 레지스트리
    - 이미지를 저장하고 배포하는 공간 (ex: 도커 허브)

## dockerfile 주요 명령어

### 1. CMD

- 컨테이너가 시작될 때 실행할 기본 명령 또는 파라미터를 정의
- 한 `dockerfile`에 유효한 `CMD`는 단 하나이다. (여러 개 존재한다면 **마지막 CMD만 유효**)
- 이미지 빌드 시점이 아닌 컨테이너 실행 시점에 동작

**CMD vs ENTRYPOINT**

- `CMD`
    - 기본 명령을 지정하되 필요 시 **쉽게 대체할 수 있음**
- `ENTRYPOINT`
    - 컨테이너 시작 시 **반드시 실행해야 하는 명령을 지정**
    - `ENTRYPOINT`에 `CMD`를 통해 기본 인자를 제공하여 **유연하게 설정 가능**

**CMD 사용 이유**

- 컨테이너 시작 시 자동으로 주 실행 명령을 실행
- 환경 변수나 외부 설정 파일을 통해 런타임 환경 유연하게 제어 가능

### 2. ENTRYPOINT

- 컨테이너 시작될 때 실행할 명령어나 스크립트를 지정하는 데 사용되는 명령어
- CMD와 다르게 실행을 필수로 고정할 때 사용

### 3. RUN

- 현재 이미지 위에 새 레이어를 생성하고 그 안에서 명령을 실행
- 패키지 서리, 파일 생성, 권한 변경 등에 사용됨
- 특징
    - 이미지 빌드 시점에 실행됨
    - 실행 시 새로운 레이어 생성

### 4. WORKDIR

- `dockerfile` 내에서 작업 디렉토리를 설정
- 이후 모든 RUN, CMD, ENTRYPOINT, COPY, ADD 명령어는 이 디렉토리를 기준으로 실행됨

**특징**

- 절대/상대 경로 모두 사용 가능
- 디렉토리 없으면 자동으로 생성
- `dockerfile` 내에서 여러 번 사용할 수 있으며, **이전 WORKDIR 경로에 상대적으로 설정**됨
    - `dockerfile` 라인 수가 길어진다면 절대 경로 사용 추천
    - 상대 경로로 작성한다면 이후 유지보수에서 실수할 수 있음

**주의사항**

- 경로에 공백이 있다면 따옴표로 묶기 : `WORKDIR "/path with spaces"`
- 상대 경로 사용할 땐 **이전 WORKDIR 설정 고려하기**

```docker
FROM node:18-slim
WORKDIR /app
COPY . .
RUN npm install
CMD ["node", "app.js"]
```

`WORKDIR /app` : `/app` 디렉토리를 작업 디렉토리로 설정

`COPY . .` : 현재 호스트 디렉토리의 파일들을 컨테이너의 `/app` 디렉토리로 복사

`RUN`, `CMD` : `/app` 디렉토리에서 실행됨

### 5. COPY

```docker
FROM node:21-alpine
WORKDIR /usr/src/app
COPY . .
```

- 첫번째 “.” : 호스트 시스템에서 dockerfile이 위치한 현재 디렉토리
- 두번째 “.” : 컨테이너 내부의 현재 작업 디렉토리 (위의 코드에선 `/usr/src/app`)
- 현재 호스트 디렉토리에 있는 모든 파일, 폴더를 컨테이너로 복사

**주의**

- 불필요하게 큰 파일이 포함되면 이미지 빌드 시간과 크기에 영향 줄 수 있음
- `.dockerignore` 파일 사용해 불필요한 파일 포함시키지 않을 수 있음

## docker run

### 옵션

- `--rm` : 컨테이너가 종료되면 자동으로 삭제되도록 설정
- `-it` : **interactive**, **tty** → 대화형 터미널 환경 제공
- `-d` : **detached** 모드 → 컨테이너 백그라운드에서 실행

## 멀티 스테이지 빌드

- 하나의 컨테이너 이미지 빌드를 여러 단계로 나누어 관리하는 방법
- **빌드에 필요한 의존성**과  **실제 배포에 필요한 파일**을 분리
- 더 작고 최적화된 이미지 생성할 수 있음
- `dockerfile`에 여러 `FROM` 명령어를 사용해 각 단계를 정의
- 각 `FROM` 명령어는 서로 다른 베이스 이미지로 새로운 빌드 단계를 시작. 한 단계에서 다른 단계로 필요한 결과물만 선택적으로 복사할 수 있음
    
    → 최종 이미지에서 불필요한 요소들을 제외할 수 있다
    
- `dockerfile`은 주로 두 단계로 구성된다
    1. 바이너리 빌드
    2. 빌드된 바이너리만 복사
- 별도의 빌드, 스크립트, 플러그인 없이 `dockerfile` 하나와 `docker build` 명령어로 멀티 스테이징을 진행할 수 있다
