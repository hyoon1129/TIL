# k8s node 관리

## Cordon & Drain

- Cordon
    - `cordon off` : 진입을 제한하기 위해 둘러싼다는 의미
    - 노드에 새로 파드가 스케줄되지 못하도록 진입 제한을 두는 역할
- Drain
    - 노드에서 기존 파드들을 다른 노드로 이동(축출)시켜서 노드를 비워내는 역할

### 사용법

1. Cordon
- `kubectl cordon <노드 이름>` : 노드에 스케줄 불가 상태 적용
- 이미 노드 위에서 작동하고 있는 파드는 그대로 동작. 하지만 새로운 파드가 스케줄링 되지 않음
1. Drain
- `kubectl drain <노드 이름>` : 해당 노드의 파드를 모두 축출해 다른 노드로 **재스케줄링** 되게 함

### 특징

- Cordon
    - 무중단 배포나 노드 점검 전에 사용
    - 이미 노드에 있는 파드는 그대로 유지
- Drain
    - 노드를 완전히 비워야 할 경우 (하드웨어 점검, OS 업데이트 등)
    - 파드를 다른 노드로 재스케줄 해 노드를 텅 비게 함
    - `DaemonSet` 파드는 기본적으로 옮겨지지 않기 때문에 추가 옵션 고려해야 함

drain 하면 cordon 자동으로 됨

## nodeName

- 특정 노드 이름을 지정해 (`nodeName`) 파드를 강제고 해당 노드에 배치하고 싶을 때 사용.
- 스케줄러가 관여하지 않음

### 특징

- 스케줄러는 `nodeName`이 지정되면 해당 파드 무시하고 바로 지정한 노드에 파드가 뜸
- 노드를 하드코딩 하게 되어 노드 장애 시 바로 실패 상태가 되거나 수동으로 복구해야함
- 우선순위 : `nodeName`  > `NodeSelector`, `NodeAffinity`

### 언제 쓸까?

- 특정 자원이 필요한 노드에서만 사용
- 고정된 개발/테스트 환경
- 다른 스케줄링 방법 복잡할 때 별도 라벨링 없이 nodeName 사용

운영 환경에선 nodeName 권장하지 않음. 노드 장애 시 서비스가 장애에 취약해질 수 있음!

## nodeLabel

- 노드에 꼬리표 (키-값) 달기
- 파드 배포 시 `nodeSelector`, `NodeAffinity` 등을 통해 특정 라벨이 있는 노드에만 스케줄링 되게 설정 가능

### 특징

- 키 값 만드로 노드에 메타 정보 설정 가능
- 배포 후에도 kubectl로 라벨 추가/수정/삭제 가능
- 노드 라벨을 통해 파드를 원하는 노드에 배치 가능
- `kubectl get nodes --show-labels` 명령으로 한눈에 확인할 수 있음

## nodeSelector

- 파드가 어떤 label을 갖춘 노드에서만 동작하도록 필터링하는 가장 기본적인 스케줄링 기능
- 파드에 nodeSelector를 정의하면 해당 라벨을 가진 노드로만 스케줄링 됨

## nodeAffinity

- 파드가 특정 노드의 라벨이나 속성 기준으로 배치되는 방식을 세밀하게 조정할 수 있게 해주는 스케줄링 기능
- `node affinity` : 이런 라벨이 달린 노드에 배치되면 좋겠다
- `node anti-affinity` : 이런 라벨이 달린 노드에 배치되지 않으면 좋겠다

### 옵션

- **`requiredDuringSchedulingIgnoredDuringExecution`**
    - 파드를 스케줄링 할 때 해당 조건이 **반드시 만족되는** 노드에만 스케줄링
    - 파드가 실행 중인 동안엔 해당 조건이 무시됨 (파드 실행되고 나서 조건이 달라져도 파드 쫓아내진 않음)
- **`preferredDuringSchedulingIgnoredDuringExecution`**
    - 해당 조건을 **가능하면** 충족하는 노드에 스케줄링 하려 함
    - 파드가 실행 중인 동안엔 그 조건이 무시됨 (실행 중 조건이 달라져도 이미 올라간 파드는 계속 실행)

## Taint와 Tolerations

- Taint : 노드에 특정 오염(조건)을 부여하고 특별히 허용되지 않는(Toleration이 없는) 파드가 스케줄링 되지 않도록 만드는 장치
- Toleration : taint된 노드에 스케줄링 될 수 있게 하는 허용 조건
- 둘을 함께 사용하면 특정 노드에만 배치되게 하거나 반대로 특정 노드로는 절대 배치되지 않게 하는 등 세밀한 제어가 가능하다

## k8s pod 관리

## PodLabel

- 파드에 라벨을 붙여 원하는 파드만 조회하거나 파드 그룹에서 서비스를 연결하는 등 작업할 수 있음

### 특징

- 키 - 값 형식
- 하나의 오브젝트에 여러 label 가능
- `selector`와 연동해 `deployments`, `replicaSet`, `Service` 등이 label을 보고 특정 파드를 선택/관리할 수 있음
- `kubectl label` 명령어로 기존 라벨 추가/수정/삭제 가능
- 주로 파드 검색/조회, 리소스 그룹화, 파이프라인에서 버전 관리 등에 사용됨

## Static Pod

- 쿠버네티스 API 서버와 상관 없이 특정 노드의 kubelet이 직접 읽고 실행하는 형태의 파드
- 보통 `/etc/kubernetes/manifests` 등의 특정 디렉터리에 놓인 YAML 파일을 kubelet이 주기적으로 스캔하여 관리
- API Server에 의해 스케줄링 되지 않고 해당 노드에서 kubelet이 스스로 기동, 재시작, 삭제를 관리

### 특징

- 노드마다 독립적 yml 파일을 둬야 해서 노드 별 세팅이 필요하다
- 이미 노드가 정해져 있어 파드 스케줄링 기능 사용할 수 없다
- 관리 범위가 제한적이다
    - kubectl delete 로 삭제 불가. (삭제해도 즉시 재생성)
    - `/etc/kubernetes/manifests`의 파일 자체를 지우거나 수정해야함

### 언제 쓸까?

- 클러스터 핵심 컴포넌트 등 k8s 자체를 구동하기 위해 API Server 보다 먼저 실행되어야 할 때
- 특정 노드에서 **절대 꺼지면 안 되는** 또는 API 서버와 관계 없이 **독립적으로 유지되어야 하는 서비스**를 구동할 때

특이한 상황이 오지 않는 이상 쓸 일이 잘 없음!
